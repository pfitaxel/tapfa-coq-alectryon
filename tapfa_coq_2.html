<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>TAPFA - Partie Coq - Preuve assist√©e</title>
<meta name="date" content="L3 Info, Semestre 6, Ann√©e 2020-2021" />
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.12.0+0.12.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tapfa-partie-coq-preuve-assistee">
<h1 class="title">TAPFA - Partie Coq - Preuve assist√©e</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="auteurs field"><th class="docinfo-name">Auteurs:</th><td class="field-body">Jean-Paul Bodeveix (resp. UE), Erik Martin-Dorel, Pierre Roux</td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>L3 Info, Semestre 6, Ann√©e 2020-2021</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<p>Supports de ce cours :</p>
<ul class="simple">
<li><a class="reference external" href="https://pfitaxel.github.io/tapfa-coq-alectryon/">https://pfitaxel.github.io/tapfa-coq-alectryon/</a></li>
</ul>
<div class="section" id="principe">
<h1>Principe</h1>
<ul class="simple">
<li>Prouver une propri√©t√© <code class="highlight coq"><span class="n">P</span></code> <span class="math">\(\equiv\)</span> Construire un terme de type <code class="highlight coq"><span class="n">P</span></code>.</li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Parameters</span> (<span class="nv">p</span> : <span class="kt">Prop</span>) (<span class="nv">q</span> : <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk0"><span class="kn">Theorem</span> <span class="nf">th</span> : p -&gt; (p -&gt; q) -&gt; q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">p -&gt; (p -&gt; q) -&gt; q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">p -&gt; (p -&gt; q) -&gt; q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> (<span class="nv">x</span> : p) (<span class="nv">f</span> : p -&gt; q) =&gt; f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><ul class="simple">
<li>Les tactiques aident √† la construction du terme de preuve:</li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk2"><span class="kn">Theorem</span> <span class="nf">th&#39;</span> : p -&gt; (p -&gt; q) -&gt; q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">p -&gt; (p -&gt; q) -&gt; q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">p -&gt; (p -&gt; q) -&gt; q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="tapfa-coq-2-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk4"><span class="kn">Print</span> th&#39;.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">th&#39; = 
<span class="kr">fun</span> (<span class="nv">H</span> : p) (<span class="nv">H0</span> : p -&gt; q) =&gt; H0 H
     : p -&gt; (p -&gt; q) -&gt; q

<span class="kn">Arguments</span> th&#39; _ _%function_scope</blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre></div>
<div class="section" id="les-principales-tactiques-de-preuve">
<h1>Les principales tactiques de preuve</h1>
<div class="section" id="la-tactique-intro-variante-intros-h-1-h-n">
<h2>La tactique <code class="highlight coq"><span class="nb">intro</span></code> (variante : <code class="highlight coq"><span class="nb">intros</span> <span class="n">H_1</span> <span class="o">‚Ä¶</span> <span class="n">H_n</span></code>)</h2>
<pre class="code Coq literal-block">
<span class="n">h_1</span> <span class="o">:</span> <span class="n">e_1</span>                       <span class="n">h_1</span> <span class="o">:</span> <span class="n">e_1</span>
   <span class="o">...</span>        <span class="o">--&gt;</span> <span class="nb">intro</span> <span class="n">H</span> <span class="o">--&gt;</span>      <span class="o">...</span>
<span class="n">h_n</span> <span class="o">:</span> <span class="n">e_n</span>                       <span class="n">h_n</span> <span class="o">:</span> <span class="n">e_n</span>
<span class="o">=========</span>                       <span class="n">H</span> <span class="o">:</span> <span class="n">p</span>
<span class="n">p</span> <span class="o">-&gt;</span> <span class="n">q</span>                          <span class="o">=========</span>
                                <span class="n">q</span>


<span class="n">h_1</span> <span class="o">:</span> <span class="n">e_1</span>                       <span class="n">h_1</span> <span class="o">:</span> <span class="n">e_1</span>
   <span class="o">...</span>        <span class="o">--&gt;</span> <span class="nb">intro</span> <span class="n">x</span> <span class="o">--&gt;</span>      <span class="o">...</span>
<span class="n">h_n</span> <span class="o">:</span> <span class="n">e_n</span>                       <span class="n">h_n</span> <span class="o">:</span> <span class="n">e_n</span>
<span class="o">============</span>                    <span class="n">x</span> <span class="o">:</span> <span class="n">t</span>
<span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">t</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span>                    <span class="o">=========</span>
                                <span class="n">P</span> <span class="n">x</span>
</pre>
<p>Cas d‚Äôutilisation de <code class="highlight coq"><span class="nb">intro</span></code></p>
<p>Lorsque le but est une implication ou une
quantification universelle <span class="math">\(\leadsto\)</span> introduction de l‚Äôhypoth√®se
dans le contexte</p>
</div>
<div class="section" id="preuve-dune-egalite">
<h2>Preuve d‚Äôune √©galit√©</h2>
<pre class="code Coq literal-block">
<span class="n">Œì</span>        <span class="o">--&gt;</span> <span class="bp">reflexivity</span> <span class="o">--&gt;</span>   <span class="o">‚àÖ</span> <span class="n">si</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t'</span>
<span class="o">======</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">t'</span>
</pre>
<p>Cas d‚Äôutilisation de <code class="highlight coq"><span class="bp">reflexivity</span></code></p>
<p>Lorsque le but est une √©galit√©
entre 2 termes identiques (modulo calcul) <span class="math">\(\leadsto\)</span> fin de la
preuve.</p>
<p>Exemple</p>
<pre class="code Coq literal-block">
<span class="n">Œì</span>          <span class="o">--&gt;</span> <span class="bp">reflexivity</span> <span class="o">--&gt;</span>   <span class="o">‚àÖ</span> <span class="o">(</span><span class="kn">Qed</span><span class="o">)</span>
<span class="o">=========</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span>
</pre>
</div>
<div class="section" id="reecriture-utilisation-dune-egalite">
<h2>R√©√©criture (utilisation d‚Äôune √©galit√©)</h2>
<p>Soit <code class="highlight coq"><span class="n">E</span> <span class="o">:</span> <span class="n">t_1</span> <span class="o">=</span> <span class="n">t_2</span></code> un th√©or√®me ou une hypoth√®se du contexte <span class="math">\(\Gamma\)</span></p>
<pre class="code Coq literal-block">
<span class="n">Œì</span>     <span class="o">--&gt;</span> <span class="nb">rewrite</span> <span class="n">E</span> <span class="o">--&gt;</span>   <span class="n">Œì</span>
<span class="o">====</span>                      <span class="o">====</span>
<span class="n">P</span> <span class="n">t1</span>                      <span class="n">P</span> <span class="n">t2</span>


<span class="n">Œì</span>     <span class="o">--&gt;</span> <span class="nb">rewrite</span> <span class="o">&lt;-</span><span class="n">E</span> <span class="o">--&gt;</span>   <span class="n">Œì</span>
<span class="o">====</span>                        <span class="o">====</span>
<span class="n">P</span> <span class="n">t2</span>                        <span class="n">P</span> <span class="n">t1</span>


<span class="n">Œì</span>                                   <span class="n">Œì</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t1</span>   <span class="o">--&gt;</span> <span class="nb">rewrite</span> <span class="n">E</span> <span class="kr">in</span> <span class="n">H</span> <span class="o">--&gt;</span>   <span class="n">H</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t2</span>
<span class="o">========</span>                            <span class="o">========</span>
<span class="n">G</span>                                   <span class="n">G</span>


<span class="n">Œì</span>                                     <span class="n">Œì</span>
<span class="n">H</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t2</span>   <span class="o">--&gt;</span> <span class="nb">rewrite</span> <span class="o">&lt;-</span><span class="n">E</span> <span class="kr">in</span> <span class="n">H</span> <span class="o">--&gt;</span>   <span class="n">H</span> <span class="o">:</span> <span class="n">P</span> <span class="n">t1</span>
<span class="o">========</span>                              <span class="o">========</span>
<span class="n">G</span>                                     <span class="n">G</span>
</pre>
</div>
<div class="section" id="reecriture-exemple">
<h2>R√©√©criture (exemple)</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk5"><span class="kn">Theorem</span> <span class="nf">exemple_de_propriete_prouvee_par_reecriture</span> :
  <span class="kr">forall</span> <span class="nv">f</span> : nat -&gt; nat,
    (<span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)) -&gt;
    f <span class="mi">2</span> = f <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat -&gt; nat,
(<span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)) -&gt; f <span class="mi">2</span> = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : nat -&gt; nat,
(<span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)) -&gt; f <span class="mi">2</span> = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk7"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)) -&gt; f <span class="mi">2</span> = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk8"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">2</span> = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk9"><span class="nb">rewrite</span> &lt;- H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">1</span> = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chka"><span class="nb">rewrite</span> &lt;- H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, f n = f (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f <span class="mi">0</span> = f <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="reecriture-cas-general-ou-le-theoreme-e-a-des-conditions">
<h2>R√©√©criture (cas g√©n√©ral o√π le th√©or√®me <tt class="docutils literal">E</tt> a des conditions)</h2>
<p>Soit
<code class="highlight coq"><span class="n">E</span> <span class="o">:</span> <span class="kr">‚àÄ</span> <span class="nv">x1</span> <span class="o">...</span> <span class="n">xk</span><span class="o">,</span>
<span class="n">p1</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span> <span class="o">-&gt;</span> <span class="o">‚ãÖ‚ãÖ‚ãÖ</span> <span class="o">-&gt;</span> <span class="n">pn</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span> <span class="o">-&gt;</span>
<span class="n">t</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span> <span class="o">=</span> <span class="n">t'</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span></code>,
un th√©or√®me ou une hypoth√®se du contexte <span class="math">\(\Gamma\)</span></p>
<pre class="code Coq literal-block">
<span class="n">Œì</span>                 <span class="o">--&gt;</span> <span class="nb">rewrite</span> <span class="n">E</span> <span class="o">--&gt;</span>   <span class="n">Œì</span>
<span class="o">===============</span>                       <span class="o">================</span>
<span class="n">P</span> <span class="o">(</span><span class="n">t</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span><span class="o">)</span>                       <span class="n">P</span> <span class="o">(</span><span class="n">t'</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span><span class="o">)</span>

                                      <span class="n">Œì</span>
                                      <span class="o">============</span>
                                      <span class="n">p1</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span>

                                      <span class="o">...</span>

                                      <span class="n">Œì</span>
                                      <span class="o">============</span>
                                      <span class="n">pn</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span>

                                      <span class="c">(* n conditions requises par le th√©or√®me E *)</span>
</pre>
</div>
<div class="section" id="reecriture-exemple-avec-une-condition">
<h2>R√©√©criture (exemple avec une condition)</h2>
<pre class="code Coq literal-block">
<span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">nat</span>                             <span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">nat</span>
<span class="n">E</span> <span class="o">:</span> <span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">O</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span>                       <span class="n">E</span> <span class="o">:</span> <span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">O</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span>
    <span class="n">S</span> <span class="o">(</span><span class="n">pred</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span>                                <span class="n">S</span> <span class="o">(</span><span class="n">pred</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">n</span> <span class="o">:</span> <span class="n">nat</span>                   <span class="o">--&gt;</span> <span class="nb">rewrite</span> <span class="n">E</span> <span class="o">--&gt;</span>   <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span>
<span class="o">=======================</span>                       <span class="o">=======================</span>
<span class="n">S</span> <span class="o">(</span><span class="n">pred</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)))</span>                        <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span>
<span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span>
                                              <span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">-&gt;</span> <span class="n">nat</span>
                                              <span class="n">E</span> <span class="o">:</span> <span class="kr">‚àÄ</span> <span class="nv">x</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">O</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span>
                                                  <span class="n">S</span> <span class="o">(</span><span class="n">pred</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span>
                                              <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span>
                                              <span class="o">===============</span>
                                              <span class="n">O</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre>
</div>
<div class="section" id="la-tactique-apply-variante-apply-h-with-x-i-v-i">
<h2>La tactique <code class="highlight coq"><span class="nb">apply</span></code> (variante : <code class="highlight coq"><span class="nb">apply</span> <span class="n">H</span> <span class="kr">with</span> <span class="o">(</span><span class="n">x_i</span><span class="o">:=</span><span class="n">v_i</span><span class="o">)</span></code> ‚Ä¶)</h2>
<p>Soit <code class="highlight coq"><span class="n">H</span> <span class="o">:</span> <span class="kr">‚àÄ</span> <span class="nv">x1</span> <span class="o">...</span> <span class="n">xk</span><span class="o">,</span>
<span class="n">p1</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span> <span class="o">-&gt;</span> <span class="o">‚ãÖ‚ãÖ‚ãÖ</span> <span class="o">-&gt;</span> <span class="n">pn</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span> <span class="o">-&gt;</span>
<span class="n">q</span> <span class="n">x1</span> <span class="o">...</span> <span class="n">xk</span></code>,
un th√©or√®me ou une hypoth√®se du contexte <span class="math">\(\Gamma\)</span></p>
<pre class="code Coq literal-block">
<span class="n">Œì</span>             <span class="o">--&gt;</span> <span class="nb">apply</span> <span class="n">H</span> <span class="o">--&gt;</span>   <span class="n">Œì</span>
<span class="o">===========</span>                     <span class="o">============</span>
<span class="n">q</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span>                     <span class="n">p1</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span>

                                <span class="o">...</span>

                                <span class="n">Œì</span>
                                <span class="o">============</span>
                                <span class="n">pn</span> <span class="n">u1</span> <span class="o">...</span> <span class="n">uk</span>

                                <span class="c">(* n conditions requises pour appliquer H *)</span>
</pre>
</div>
<div class="section" id="la-tactique-apply-exemple">
<h2>La tactique <code class="highlight coq"><span class="nb">apply</span></code> (exemple)</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="tapfa-coq-2-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chkb"><span class="kn">Search</span> concl:(_ &lt;= _) S.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">le_S: <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; n &lt;= S m</blockquote><blockquote class="alectryon-message">le_n_S: <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; S n &lt;= S m</blockquote><blockquote class="alectryon-message">le_S_n: <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, S n &lt;= S m -&gt; n &lt;= m</blockquote></div></div></small><span class="alectryon-wsp">
</span></span></pre><p>(<a class="reference external" href="https://coq.github.io/doc/V8.12.2/refman/proof-engine/vernacular-commands.html#coq:cmd.search">documentation de la commande Search</a>)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chkc"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">n</span>, n &lt;= S (S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt;= S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n &lt;= S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chke"><span class="nb">intro</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chkf"><span class="kn">Check</span> le_S.  <span class="c">(* r√©affichons le lemme le_S, juste pour rappel *)</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">le_S
     : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n &lt;= m -&gt; n &lt;= S m</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk10"><span class="nb">apply</span> le_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= S n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
<div class="section" id="la-tactique-induction-applique-le-theoreme-dinduction">
<h2>La tactique <code class="highlight coq"><span class="nb">induction</span></code> : applique le th√©or√®me d‚Äôinduction</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk11"><span class="kn">Theorem</span> <span class="nf">add_comm</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk13"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> : nat, <span class="mi">0</span> + m = m + <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tapfa-coq-2-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br></div><label class="goal-separator" for="tapfa-coq-2-v-chk14"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">m</span> : nat, S n + m = m + S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
<div class="section" id="la-tactique-destruct-preuve-par-cas">
<h2>La tactique <code class="highlight coq"><span class="nb">destruct</span></code> : preuve par cas</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk15"><span class="kn">Theorem</span> <span class="nf">addn1_neq0</span> : <span class="kr">forall</span> <span class="nv">n</span> : nat, n + <span class="mi">1</span> &lt;&gt; <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n + <span class="mi">1</span> &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat, n + <span class="mi">1</span> &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk17"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> + <span class="mi">1</span> &lt;&gt; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tapfa-coq-2-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="tapfa-coq-2-v-chk18"><hr></label><div class="goal-conclusion">S n + <span class="mi">1</span> &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></div></small></span></pre></div>
<div class="section" id="la-tactique-simpl-simplification-du-but">
<h2>La tactique <code class="highlight coq"><span class="nb">simpl</span></code> : simplification du but</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk19"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &lt;&gt; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tapfa-coq-2-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="tapfa-coq-2-v-chk1a"><hr></label><div class="goal-conclusion">S n + <span class="mi">1</span> &lt;&gt; <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre></div>
<div class="section" id="detail-reduction-des-expressions-0-n-1-n-n-0-n-1">
<h2>D√©tail : r√©duction des expressions <code class="highlight coq"><span class="mi">0</span><span class="o">+</span><span class="n">n</span></code>, <code class="highlight coq"><span class="mi">1</span><span class="o">+</span><span class="n">n</span></code>, <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">0</span></code>, <code class="highlight coq"><span class="n">n</span><span class="o">+</span><span class="mi">1</span></code></h2>
<p>√âtant donn√©e que la fonction <code class="highlight coq"><span class="o">(</span><span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span></code> est
d√©finie r√©cursivement par rapport √† son premier argument :</p>
<ul>
<li><p class="first"><code class="highlight coq"><span class="mi">0</span> <span class="o">+</span> <span class="n">n</span></code> se r√©duit par calcul √† <code class="highlight coq"><span class="n">n</span></code></p>
</li>
<li><p class="first"><code class="highlight coq"><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span></code> se r√©duit par calcul √† <code class="highlight coq"><span class="n">S</span> <span class="n">n</span></code></p>
</li>
<li><p class="first"><span class="math">\(\leadsto\)</span> donc on peut prouver trivialement <code class="highlight coq"><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="o">=</span> <span class="n">S</span> <span class="n">n</span></code> (par r√©flexivit√©)</p>
</li>
<li><p class="first">mais <strong>on a besoin d‚Äôune preuve par induction</strong> pour montrer que</p>
<pre class="code Coq literal-block">
<span class="kr">‚àÄ</span> <span class="nv">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">=</span> <span class="n">n</span>
<span class="kr">‚àÄ</span> <span class="nv">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">S</span> <span class="n">n</span>
</pre>
</li>
</ul>
<p>Autres tactiques Autres tactiques non d√©taill√©es dans ces transparents :</p>
<ul class="simple">
<li><code class="highlight coq"><span class="bp">exact</span></code></li>
<li><code class="highlight coq"><span class="nb">symmetry</span></code>, <code class="highlight coq"><span class="nb">transitivity</span></code></li>
<li><code class="highlight coq"><span class="nb">constructor</span></code>, <code class="highlight coq"><span class="nb">split</span></code>, <code class="highlight coq"><span class="nb">left</span></code>, <code class="highlight coq"><span class="nb">right</span></code>, <code class="highlight coq"><span class="kr">exists</span></code>,
<code class="highlight coq"><span class="bp">discriminate</span></code>, <code class="highlight coq"><span class="nb">injection</span></code></li>
<li><code class="highlight coq"><span class="nb">unfold</span></code></li>
<li><code class="highlight coq"><span class="bp">lia</span></code> (Linear Integer Arithmetic), <code class="highlight coq"><span class="bp">tauto</span></code>, <code class="highlight coq"><span class="nb">firstorder</span></code></li>
</ul>
<p>Pour plus de d√©tails, voir l‚ÄôAide-m√©moire des tactiques de preuve Coq</p>
</div>
<div class="section" id="retour-sur-la-correspondance-preuve-programme-curry-howard">
<h2>Retour sur la correspondance &quot;preuve-programme&quot; (Curry-Howard)</h2>
<p>Coq fournit un langage de tactiques qui permet de construire
<strong>interactivement</strong> et <strong>incr√©mentalement</strong>, un programme fonctionnel
(le &quot;terme de preuve&quot;).  Lorsque la construction de ce programme est
termin√©e, son type est v√©rifi√© par Coq au moment du <code class="highlight coq"><span class="kn">Qed</span></code> par rapport
au type attendu (c.-√†-d. par rapport √† la formule logique qui devait
√™tre d√©montr√©e).</p>
<p>L'exemple qui suit, qui peut √™tre jou√© dans la derni√®re version de
ProofGeneral en activant deux fonctionnalit√©s sp√©cifiques dans l'IDE,
illustre ce principe :</p>
<ul class="simple">
<li>Menu <tt class="docutils literal">Coq &gt; Show Proof</tt> (<tt class="docutils literal"><span class="pre">M-x</span> <span class="pre">coq-show-proof-stepwise-toggle</span> RET</tt>)</li>
<li>Menu <tt class="docutils literal">Coq &gt; Diffs &gt; On</tt> (<tt class="docutils literal">ESC ` c D O</tt>)</li>
</ul>
<p>(en utilisant aussi si besoin, le menu <tt class="docutils literal">Coq &gt; Toggle 3 Windows mode</tt>
ainsi que le raccourci <tt class="docutils literal"><span class="pre">C-c</span> <span class="pre">C-l</span>&nbsp; <span class="pre">C-c</span> <span class="pre">C-p</span></tt>)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk1b"><span class="kn">Lemma</span> <span class="nf">example</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Prop</span>,
    (A -&gt; B -&gt; C) -&gt; (A /\ B -&gt; C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Prop</span>, (A -&gt; B -&gt; C) -&gt; A /\ B -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Prop</span>, (A -&gt; B -&gt; C) -&gt; A /\ B -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk1d"><span class="nb">intros</span> A B C. <span class="c">(* notez l&#39;apparition d&#39;un fun ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(A -&gt; B -&gt; C) -&gt; A /\ B -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk1e"><span class="nb">intros</span> hABC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hABC</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A /\ B -&gt; C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk1f"><span class="nb">intros</span> hAB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hABC</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>hAB</var><span class="hyp-type"><b>: </b><span>A /\ B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk20"><span class="nb">destruct</span> hAB. <span class="c">(* notez l&#39;apparition d&#39;un match-with ... *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hABC</var><span class="hyp-type"><b>: </b><span>A -&gt; B -&gt; C</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> hABC; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
</div>
<div class="section" id="exemples-et-exercices-autour-des-listes">
<h1>Exemples et exercices autour des listes</h1>
<div class="section" id="preliminaires">
<h2>Pr√©liminaires</h2>
<p>Pour charger la biblioth√®que des listes (et les notations
√† la OCaml) puis activer les arguments implicites pour vos d√©finitions,
ajoutez au d√©but de votre fichier :</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span></span></pre></div>
<div class="section" id="quelques-preuves-de-theoremes-de-la-stdlib-sur-les-listes">
<h2>Quelques preuves (de th√©or√®mes de la stdlib) sur les listes</h2>
<p><strong>But</strong> Prouver que la double inversion d‚Äôune liste renvoie la liste
inchang√©e :</p>
<pre class="code Coq literal-block">
<span class="kr">‚àÄ</span> <span class="nv">T</span> <span class="o">(</span><span class="nv">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">),</span> <span class="n">rev</span> <span class="o">(</span><span class="n">rev</span> <span class="n">l</span><span class="o">)</span> <span class="o">=</span> <span class="n">l</span>
</pre>
<p>La fonction <code class="highlight coq"><span class="n">List</span><span class="o">.</span><span class="n">rev</span></code> est d√©finie comme suit :</p>
<pre class="code Coq literal-block">
<span class="kn">Fixpoint</span> <span class="nf">rev</span> <span class="o">(</span><span class="nv">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="nv">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kr">match</span> <span class="n">l</span> <span class="kr">with</span>
  <span class="o">|</span> <span class="o">[]</span> <span class="o">=&gt;</span> <span class="o">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">l</span><span class="o">‚Äô</span> <span class="o">=&gt;</span> <span class="n">rev</span> <span class="n">l</span><span class="o">‚Äô</span> <span class="o">++</span> <span class="o">[</span><span class="n">x</span><span class="o">]</span>
  <span class="kr">end</span><span class="o">.</span>
</pre>
<p>o√π <code class="highlight coq"><span class="o">++</span></code> est une notation Coq qui √©quivaut √† <tt class="docutils literal">&#64;</tt> en OCaml.</p>
<p><strong>M√©thode</strong> On part du th√©or√®me √† prouver et on identifie au fur et √†
mesure les lemmes interm√©diaires qui m√©ritent d‚Äô√™tre prouv√©s √† part.</p>
</div>
<div class="section" id="premier-lemme">
<h2>Premier lemme</h2>
<p>Prouver (par induction sur la liste <code class="highlight coq"><span class="n">l1</span></code>) que l‚Äôon a :</p>
<pre class="code Coq literal-block">
<span class="kn">Lemma</span> <span class="nf">app_nil</span> <span class="o">:</span> <span class="kr">forall</span> <span class="o">(</span><span class="nv">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="nv">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">),</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span> <span class="o">++</span> <span class="o">[].</span>
</pre>
<p>Rappel: la fonction <code class="highlight coq"><span class="o">(</span><span class="kr">fun</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="o">=&gt;</span> <span class="n">l1</span> <span class="o">++</span> <span class="n">l2</span><span class="o">)</span></code> est d√©finie comme suit :</p>
<pre class="code Coq literal-block">
<span class="kn">Fixpoint</span> <span class="nf">app</span> <span class="o">(</span><span class="nv">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="nv">l1</span> <span class="nv">l2</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kr">match</span> <span class="n">l1</span> <span class="kr">with</span>
  <span class="o">|</span> <span class="o">[]</span> <span class="o">=&gt;</span> <span class="n">l2</span>
  <span class="o">|</span> <span class="n">x1</span> <span class="o">::</span> <span class="n">l1</span> <span class="o">=&gt;</span> <span class="n">x1</span> <span class="o">::</span> <span class="n">app</span> <span class="n">l1</span> <span class="n">l2</span>
  <span class="kr">end</span><span class="o">.</span>
</pre>
<p>Sauriez vous l'√©crire en OCaml ?</p>
</div>
<div class="section" id="premier-lemme-preuve-par-induction">
<h2>Premier lemme ‚Äì preuve par induction</h2>
<p>√Ä la main :</p>
<p>Prouvons le lemme <code class="highlight coq"><span class="n">app_nil</span></code> par induction structurelle sur la liste <code class="highlight coq"><span class="n">l</span></code>.</p>
<ul class="simple">
<li>Cas de base (si <code class="highlight coq"><span class="n">l</span></code> est la liste vide <code class="highlight coq"><span class="o">[]</span></code>). On doit montrer que
<code class="highlight coq"><span class="o">[]</span> <span class="o">=</span> <span class="o">[]</span> <span class="o">++</span> <span class="o">[]</span></code>, soit, apr√®s simplification de la d√©finition de <code class="highlight coq"><span class="n">app</span></code>,
<code class="highlight coq"><span class="o">[]</span> <span class="o">=</span> <span class="o">[]</span></code>. CQFD.</li>
<li>Cas inductif (si <code class="highlight coq"><span class="n">l</span></code> est de la forme <code class="highlight coq"><span class="n">x</span> <span class="o">::</span> <span class="n">l'</span></code>).
Fixons un <code class="highlight coq"><span class="n">x</span> <span class="o">:</span> <span class="n">T</span></code> et un <code class="highlight coq"><span class="n">l'</span> <span class="o">:</span> <span class="n">list</span> <span class="n">T</span></code>, supposons que <code class="highlight coq"><span class="n">l'</span> <span class="o">=</span> <span class="n">l'</span> <span class="o">++</span> <span class="o">[]</span></code>
et appelons cette hypoth√®se d'induction <code class="highlight coq"><span class="n">IHl</span></code>.
Montrons qu'alors <code class="highlight coq"><span class="n">x</span> <span class="o">::</span> <span class="n">l'</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">l'</span><span class="o">)</span> <span class="o">++</span> <span class="o">[]</span></code>.
En simplifiant la d√©finition de <code class="highlight coq"><span class="n">app</span></code> on doit donc prouver que
<code class="highlight coq"><span class="n">x</span> <span class="o">::</span> <span class="n">l'</span> <span class="o">=</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">l'</span> <span class="o">++</span> <span class="o">[])</span></code>, soit apr√®s avoir utilis√© <code class="highlight coq"><span class="n">IHl</span></code>, que
<code class="highlight coq"><span class="n">x</span> <span class="o">::</span> <span class="n">l'</span> <span class="o">=</span> <span class="n">x</span> <span class="o">::</span> <span class="n">l'</span></code>. CQFD.</li>
</ul>
</div>
<div class="section" id="premier-lemme-preuve-par-induction-version-coq">
<h2>Premier lemme ‚Äì preuve par induction (version Coq)</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk21"><span class="kn">Lemma</span> <span class="nf">app_nil</span> : <span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), l = l ++ [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), l = l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), l = l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk23"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = [] ++ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tapfa-coq-2-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><label class="goal-separator" for="tapfa-coq-2-v-chk24"><hr></label><div class="goal-conclusion">a :: l = (a :: l) ++ []</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk25">{ <span class="c">(* accolades conseill√©es pour d√©limiter les preuves du sous but *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = [] ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk26"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk27">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = (a :: l) ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk28"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a :: l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk29"><span class="nb">rewrite</span> &lt;- IHl. <span class="c">(* utilise l‚Äôhypoth√®se d‚Äôinduction *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Pour appliquer <code class="highlight coq"><span class="nb">simpl</span></code> √† chaque sous-but g√©n√©r√© il suffit d‚Äô√©crire
la tactique une fois apr√®s &quot;;&quot;</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk2a"><span class="kn">Lemma</span> <span class="nf">app_nil&#39;</span> : <span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), l = l ++ [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), l = l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), l = l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk2c"><span class="nb">induction</span> l; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tapfa-coq-2-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><label class="goal-separator" for="tapfa-coq-2-v-chk2d"><hr></label><div class="goal-conclusion">a :: l = a :: l ++ []</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk2e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk2f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a :: l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk30"><span class="nb">rewrite</span> &lt;- IHl. <span class="c">(* utilise l‚Äôhypoth√®se d‚Äôinduction *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>l = l ++ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="deuxieme-lemme">
<h2>Deuxi√®me lemme</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk31"><span class="kn">Lemma</span> <span class="nf">app_assoc</span> :
  <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list T), l1 ++ (l2 ++ l3) = (l1 ++ l2) ++ l3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list T),
l1 ++ l2 ++ l3 = (l1 ++ l2) ++ l3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list T),
l1 ++ l2 ++ l3 = (l1 ++ l2) ++ l3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk33"><span class="nb">induction</span> l1; <span class="nb">simpl</span>; <span class="nb">intros</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> <span class="nv">l3</span> : list T,
l1 ++ l2 ++ l3 = (l1 ++ l2) ++ l3</span></span></span><br><span><var>l2, l3</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l1 ++ l2 ++ l3 = a :: (l1 ++ l2) ++ l3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk34"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> <span class="nv">l3</span> : list T,
l1 ++ l2 ++ l3 = (l1 ++ l2) ++ l3</span></span></span><br><span><var>l2, l3</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: (l1 ++ l2) ++ l3 = a :: (l1 ++ l2) ++ l3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p><code class="highlight coq"><span class="nb">auto</span></code> essaie d‚Äôappliquer r√©cursivement les hypoth√®ses
(et certains lemmes standard, comme la r√©flexivit√©)
pour prouver le sous-but ; sinon la tactique ne fait rien.</p>
</div>
<div class="section" id="troisieme-lemme">
<h2>Troisi√®me lemme</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk35"><span class="kn">Lemma</span> <span class="nf">rev_app_distr</span> :
  <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list T), rev (l1 ++ l2) = rev l2 ++ rev l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list T),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list T),
rev (l1 ++ l2) = rev l2 ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk37"><span class="nb">induction</span> l1; <span class="nb">simpl</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev l2 = rev l2 ++ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tapfa-coq-2-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list T,
rev (l1 ++ l2) = rev l2 ++ rev l1</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><label class="goal-separator" for="tapfa-coq-2-v-chk38"><hr></label><div class="goal-conclusion">rev (l1 ++ l2) ++ [a] = rev l2 ++ rev l1 ++ [a]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk39"><span class="nb">apply</span> app_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list T,
rev (l1 ++ l2) = rev l2 ++ rev l1</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (l1 ++ l2) ++ [a] = rev l2 ++ rev l1 ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk3a"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list T,
rev (l1 ++ l2) = rev l2 ++ rev l1</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rev l2 ++ rev l1) ++ [a] = rev l2 ++ rev l1 ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk3b"><span class="nb">rewrite</span> app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>T</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>T</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list T,
rev (l1 ++ l2) = rev l2 ++ rev l1</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list T</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(rev l2 ++ rev l1) ++ [a] = (rev l2 ++ rev l1) ++ [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="le-theoreme-vise">
<h2>Le th√©or√®me vis√©</h2>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk3c"><span class="kn">Theorem</span> <span class="nf">rev_involutive</span> : <span class="kr">forall</span> <span class="nv">T</span> (<span class="nv">l</span> : list T), rev (rev l) = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), rev (rev l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tapfa-coq-2-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="tapfa-coq-2-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">T</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list T), rev (rev l) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* exercice ! *)</span>
<span class="c">(* Qed. *)</span></span></pre></div>
</div>
</div>
</div>
</div></body>
</html>
